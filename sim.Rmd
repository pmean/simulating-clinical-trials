---
title: "Simulating clinical trials"
author: "Steve Simon"
date: "March 22, 2017"
output: html_document
---

```{r preliminaries, echo=FALSE, message=FALSE, warning=FALSE}
library(broom)
library(cowplot)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(knitr)
library(magrittr)
library(quantreg)
library(rstan)
library(tidyr)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
opts_chunk$set(
  echo=FALSE,
  message=FALSE,
  warning=FALSE,
  fig.width=5)
```

# Simulation before, during, and after a clinical trial: A Bayesian approach

## Abstract

Simulation of a clinical trial gives you answers to important economic, logistical, or scientific questions about the trial when some of the features are difficult to characterize with perfect precision. A Bayesian approach with informative priors offers a flexible framework for trial simulation. It provides a seamless transition from simulation prior to the trial to simulation during the trial itself. Although informative priors are controversial, you can avoid perceptions of bias by restricting the informative priors to clinical trial features that are independent of your research hypothesis. You can protect your interim predictions against unrealistic prior beliefs by implementing the hedging hyperprior, a simple hyperdistribution that downweights the strength of the prior when there is a discrepancy between the prior distribution and data observed during the trial itself. The Bayesian approach also gives you a simple post mortem analysis after the trial ends. You can compute percentile values by plugging the point estimates from the actual clinical trial data into the corresponding prior distributions. Over multiple trials, a deviation in these percentiles from a uniform distribution indicates biased specification of the informative priors. The Bayesian approach to trial simulation will be illustrated using various patient accrual models.

## Keywords

hedging hyperprior; informative prior distributions; Markov Chain Monte Carlo; patient accrual.

## Introduction

Consider a clinical trial that plans to run for 3 years (1,095 days). You hope to recruit 350 patients in that time, which would mean `r round(350/1095, 2)` patients per day or `r round(30*350/1095, 1)` patients per month. You suspect, however, that the accrual rate might actually be quite a bit higher or quite a bit lower than this target.

## Boxplot of prior distribution

Try setting a distribution on the monthly accrual rate that is gamma(70, 7.3). There's a farily simple justification behind this choice, but for now let's not worry about how we choose this particular distribution, except that it represents a prior strength of 0.2 relative to the target sample size.

```{r gamma_prior_2, echo=FALSE, fig.width=5, fig.height=1}
df1 <- data.frame(s=0.2, y=rgamma(1000, 0.2*350, 0.2*1095/30))

ggplot(df1, aes(factor(s), y)) +
  geom_boxplot() +
  labs(x="", y="Monthly accrual rate") +
  coord_flip()
```

That seems a bit too wide, so try a distribution that is gamma(175, 18.25). This represents a prior strength of 0.5 relative to the target sample size.

```{r gamma_prior_5, echo=FALSE, fig.width=5, fig.height=1.33}
df2 <- rbind(df1, data.frame(s=0.5, y=rgamma(1000, 0.5*350, 0.5*1095/30)))

ggplot(df2, aes(factor(s), y)) +
  geom_boxplot() +
  labs(x="", y="Monthly accrual rate") +
  coord_flip()
```

The second distribution seems to match your gut feeling about accrual because a monthly accrual rate is unlikely to be smaller than 7.5 patients per month or more than 12.5 patients per month.

## Simulating various features of a trial

Now you are ready to simulate your clinical trial. You can simulate the amount of time that the trial takes to recruit 350 patients.

```{r simulate_time, fig.height=5}
# I'm going to cheat here. A proper simulation would use
#   lambda <- rgamma(1, 0.5*350, 0.5*1095)
# but to make the plots look a bit cleaner, I'm going to
# deliberately choose from the left tail, then the middle,
# and then the right tail of this gamma distribution.
lambda <- qgamma(runif(1, 0.01, 0.1), 0.5*350, 0.5*1095)
df <- data.frame(g=1, n=1:350, t=cumsum(rexp(350, lambda)))
lambda <- qgamma(runif(1, 0.4, 0.6), 0.5*350, 0.5*1095)
df <- rbind(df, data.frame(g=2, n=1:350, t=cumsum(rexp(350, lambda))))
lambda <- qgamma(runif(1, 0.9, 0.99), 0.5*350, 0.5*1095)
df <- rbind(df, data.frame(g=3, n=1:350, t=cumsum(rexp(350, lambda))))
t_total <- df$t[df$n==350]

ggplot(df, aes(x=n, y=t, group=g)) +
  geom_line() +
  geom_vline(xintercept=350) + 
  scale_x_continuous(breaks=50*(0:10)) +
  scale_y_continuous(breaks=365*(0:3)) +
  geom_label(aes(x=350), y=t_total[1], label=round(t_total[1]), size=2.5) +  
  geom_label(aes(x=350), y=t_total[2], label=round(t_total[2]), size=2.5) +  
  geom_label(aes(x=350), y=t_total[3], label=round(t_total[3]), size=2.5) + 
  coord_flip()

```

or the number of patients that you will get in 3 years.

```{r simulate_n, echo=FALSE, fig.width=5, fig.height=5}
lambda <- qgamma(runif(1, 0.01, 0.1), 0.5*350, 0.5*1095)
df <- data.frame(g=1, t=1:1095, n=cumsum(rpois(1095, lambda)))
lambda <- qgamma(runif(1, 0.4, 0.6), 0.5*350, 0.5*1095)
df <- rbind(df, data.frame(g=2, t=1:1095, n=cumsum(rpois(1095, lambda))))
lambda <- qgamma(runif(1, 0.9, 0.99), 0.5*350, 0.5*1095)
df <- rbind(df, data.frame(g=3, t=1:1095, n=cumsum(rpois(1095, lambda))))
n_total <- df$n[df$t==1095]

ggplot(df, aes(x=n, y=t, group=g)) +
  geom_line() +
  geom_hline(yintercept=1095) +
  scale_x_continuous(breaks=50*(0:10)) +
  scale_y_continuous(breaks=365*(0:3)) +
  geom_label(aes(x=n_total[1], y=1095, label=n_total[1]), size=2.5) +  
  geom_label(aes(x=n_total[2], y=1095, label=n_total[2]), size=2.5) +  
  geom_label(aes(x=n_total[3], y=1095, label=n_total[3]), size=2.5) +
  coord_flip()
```

Or a trial that ends when you reach 350 patients or 3 years, whichever comes first.

```{r simulate_n_and_time, echo=FALSE, fig.width=5, fig.height=5}
lambda <- qgamma(runif(1, 0.01, 0.1), 0.5*350, 0.5*1095)
df <- data.frame(g=1, t=1:1095, n=cumsum(rpois(1095, lambda)))
lambda <- qgamma(runif(1, 0.4, 0.6), 0.5*350, 0.5*1095)
df <- rbind(df, data.frame(g=2, t=1:1095, n=cumsum(rpois(1095, lambda))))
lambda <- qgamma(runif(1, 0.9, 0.99), 0.5*350, 0.5*1095)
df <- rbind(df, data.frame(g=3, t=1:1095, n=cumsum(rpois(1095, lambda))))
df$n[df$n>350] <- 350
co <- c(FALSE, df$n[-1]==350 & df$n[-3*1095]==350)
df <- df[!co, ]
df %>% 
  group_by(g) %>%
  slice(n())  %>%
  mutate(lb=paste(t, n, sep=", ")) -> total

ggplot(df, aes(x=n, y=t, group=g)) +
  geom_line() +
  scale_x_continuous(breaks=50*(0:10)) +
  scale_y_continuous(breaks=365*(0:3)) +
  geom_hline(yintercept=1095) +
  geom_vline(xintercept=350) +
  geom_label(aes(x=total$n[1], y=total$t[1], label=total$lb[1]), size=2.5) +  
  geom_label(aes(x=total$n[2], y=total$t[2], label=total$lb[2]), size=2.5) +  
  geom_label(aes(x=total$n[3], y=total$t[3], label=total$lb[3]), size=2.5) +
  coord_flip()
```

You could compute some composite measure like the total cost of the trial where each day that the trial is running costs 200 British Pounds and each patient recruited costs 800 British Pounds.

```{r simulate_cost, echo=FALSE, fig.width=5, fig.height=5}
df %>% 
  group_by(g) %>%
  slice(n())  %>%
  mutate(lb=paste0("£", format(800*n+200*t, big.mark=","))) -> total
xa <- 50*(0:7)
xb <- paste0("£", format(xa*800, big.mark=","))
ya <- 365*(0:3)
yb <- paste0("£", format(ya*200, big.mark=","))

ggplot(df, aes(x=n, y=t, group=g)) +
  geom_line() +
  labs(x="Cost of patients", y="Cost of time") +
  scale_x_continuous(breaks=xa, labels=xb) +
  scale_y_continuous(breaks=ya, labels=yb) +
  geom_hline(yintercept=1095) +
  geom_vline(xintercept=350) +
  geom_label(aes(x=total$n[1], y=total$t[1], label=total$lb[1]), size=2.5) +  
  geom_label(aes(x=total$n[2], y=total$t[2], label=total$lb[2]), size=2.5) +  
  geom_label(aes(x=total$n[3], y=total$t[3], label=total$lb[3]), size=2.5) +
  coord_flip()
```

## Paths in a simulation

You won't do this three times. You'll do it several thousand times, because computer cycles are cheap. Here's what a few thousand simulations might look like.

```{r paths-before-trial, echo=FALSE, fig.width=5, fig.height=5}
f <- "paths-before-trial.stan"
dat_before <- list(N=350, T=3*365, S=0.5)
fit_tr1 <- stan(file=f,
  data=dat_before, iter= 1000, warmup=100, chains = 4)

# tidy(fit_tr1)

fit_tr1              %>%
  as.data.frame                %>%
  select(starts_with('Nstar')) -> sim_tr1
sim_tr1$j <- 1:dim(sim_tr1)[1]
sim_tr1 %<>% gather(x, y, starts_with('Nstar'))
# head(sim_tr1)

sim_tr1$x %<>%
  sub("Nstar\\[", "", .) %>%
  sub("\\]", "", .)      %>%
  as.numeric
# head(sim_tr1)

sim_tr1 %>%
  ggplot(aes(x, y, group=j)) +
  geom_step(alpha=0.01) +
  scale_y_continuous(breaks=50*(0:10)) +
  scale_x_continuous(breaks=365*(0:3)) +
  expand_limits(y=500)                 +
  labs(x="Time", y="Sample size")
```

```{r alternate_path_plots, echo=FALSE, eval=FALSE}
sim_tr1 %>%
  group_by(x) %>%
  summarize(
    y10=quantile(y, 0.1),
    y25=quantile(y, 0.25),
    y50=quantile(y, 0.5),
    y75=quantile(y, 0.75),
    y90=quantile(y, 0.9)) %>%
  ggplot(aes(x, ymin=y10, ymax=y90)) +
    coord_flip()                         +
    geom_ribbon(fill="black", alpha=0.5) +
    geom_ribbon(aes(x, ymin=y25, ymax=y75), fill="black", alpha=0.5) +
    geom_line(aes(x, y50), color="white")

sim_tr1 %>%
  filter(x==1095) %>%
  ggplot(aes(y)) +
  geom_histogram()

sim_tr1 %>%
  filter((x %% 60)==0) %>%
  mutate(x=x/30) %>%
  ggplot(aes(x=factor(x), y=y)) +
  geom_boxplot()

```

I also want to talk about simulating a clinical trial during the trial. What this means is that you have information sample size up to a certain point in time and you want to simulate how rapidly the sample size might increase for the remainder of time in the trial.

```{r path-during-trial, echo=FALSE, fig.width=5, fig.height=5}
pts <- unlist(read.csv("count.csv"))
f <- "paths-during-trial.stan"
dat_during <- list(N=350, T=3*365, S=0.5, n=pts, t=length(pts))
fit_tr2 <- stan(file=f,
  data=dat_during, iter= 1000, warmup=100, chains = 4)

fit_tr2              %>%
  as.data.frame                %>%
  select(starts_with('Nstar')) -> sim_tr2
sim_tr2$j <- 1:dim(sim_tr2)[1]
sim_tr2 %<>% gather(x, y, starts_with('Nstar'))

sim_tr2$x %<>%
  sub("Nstar\\[", "", .) %>%
  sub("\\]", "", .)      %>%
  as.numeric

sim_tr2 %>%
  ggplot(aes(x, y, group=j)) +
  geom_step(alpha=0.01) +
  scale_y_continuous(breaks=50*(0:10)) +
  scale_x_continuous(breaks=365*(0:3)) +
  expand_limits(y=500)                 +
  labs(x="Time", y="Sample size")

```

## Gamma Poisson models

From this point onward, we'll summarize the simulations using means and standard errors and boxplots, but it's worth remembering that what we are actually simulating is random paths.

Let's also focus on simulations of the total sample size. In a Bayesian perspective, this is a Gamma Poisson model. The Poisson distribution models patient counts and a Gamma distribution restricts the rate parameter of the Poisson to a reasonable range.

While most Bayesian models use flat, non-informative, or only weakly informative prior distributions, when you are simulating the operational features of a clinical trial, you need to be bold and use strong informative prior distributions. There are two reasons for this.

First, if the best you can do for accrual rates for a clinical trial is a flat prior, what you are really saying is that you think you might see a couple of patients every day, or maybe a couple of patients every year, and you really don't have a strong belief of one of these accrual rates over another. Anyone who can only predict accrual rates across such a wide range is unqualified to run a clinical trial.

Second, if you run a simulation with a flat prior you get results with an unrealisticly wide range.

The commonly cited objection to informative priors is that they can bias the research. Whether that is true or not in a hypothesis testing framework is a matter of open debate. But using informative priors for operational characteristics of a study will not bias any resulting hypothesis tests.

Here is code in Stan (running inside of R) that simulates the results of a clinical trial with a target goal of 350 patients in 3 years (1095 days) and places a range of uncertainty on the accrual rate that is characterized by a gamma(175, 547.5). This is a prior distribution with a strength roughly equal to half the target sample size.

```{r gamma-poisson-before-trial, fig.height=1}
f <- "gamma-poisson-before-trial.stan"
dat_before <- list(N=350, T=3*365, S=0.5)
fit_gp1 <- stan(file=f,
  data=dat_before, iter= 10000, warmup=1000, chains = 4)
# Here's what's hiding in the file 
cat(readLines(f), sep="\n")

# tidy(fit_gp1)

fit_gp1              %>%
  as.data.frame      %>%
  mutate(i="before") -> sim_gp1
```

```{r boxplot1, fig.height=2}
# Boxplot of total sample size
sim_gp1                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")     + 
  xlab(" ")                               +
  ggtitle(f)                              +
  geom_boxplot()                          +
  expand_limits(y=0)                      +
  coord_flip()                           -> boxplot_gp1
print(boxplot_gp1)
```

You can learn a lot by looking at how the estimated total sample size relates to the prior paramter(s). 

Recall that in this simulation, you randomly select an accrual rate, gamma, and then you simulate a path based on that value of lambda. Not too surprisingly, the sample size depends on what lambda is chosen, though there is some variation, even for the same value of lambda.

```{r scatterplot1, fig.height=5}
# Scatterplot of accrual rate versus total sample size
sim_gp1                                       %>%
  ggplot(aes(Nstar, 30*lambda))                 +
  geom_point()                                  +
  xlab("Estimated total sample size")           + 
  ylab("Accrual rate")                          +
  expand_limits(x=0)                            +
  coord_flip()
```

With a plot like this, you can run some sensitivity checks, such as "what would happen if the accrual rate were closer to 8.5 patients per month"

```{r scatterplot2, fig.height=5}
# Scatterplot of accrual rate versus total sample size
sim_gp1                                       %>%
  mutate(h=(30*lambda>8.45)*(30*lambda<8.55)) %>%
  mutate(lambda=ifelse(h==0, lambda, 8.5/30)) %>%
  arrange(h)                                  %>%
  ggplot(aes(Nstar, 30*lambda))                 +
  xlab("Estimated total sample size")           + 
  ylab("Accrual rate")                          +
  expand_limits(x=0)                            +
  geom_point(aes(color=factor(h)))              +    
   theme(legend.position="none")                +
  coord_flip()                                  +
  scale_color_manual(values=c("gray90", "red"))
```

The key reason that you should run your simulations in Stan is that you can make a seamless transition to a simulation of a clinical trial during the trial itself. In this trial, the early accrual rate was much lower than expected. After 239 days, you have only gotten 41 patients. If you were on target, you would have 239/1095*350 = `r round(239/1095*350)` patients by now. HOw much is this shortfall hurting us?

```{r gamma-poisson-during-trial, echo=FALSE, fig.width=5, fig.height=2.5}
f <- "gamma-poisson-during-trial.stan"
dat_during <- list(N=350, T=3*365, S=0.5, n=41, t=239)
fit_gp2 <- stan(file=f,
  data=dat_during, iter= 1000, chains = 4)

# Here's what's hiding in the file 
cat(readLines(f), sep="\n")

# tidy(fit_gp2)

fit_gp2              %>%
  as.data.frame      %>%
  mutate(i="during") %>%
  bind_rows(sim_gp1) -> sim_gp2

# Boxplot of total sample size
sim_gp2                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")     + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()
```

For this trial, you were able to get 341 patients, but it took a lot longer than you expected, 1336 days instead of 1095 days. Time to get ready for your next clinical trial. NOT SO FAST! You are not done with simulations when the trial is over. After the trial, take a look at how your accrual rate ranks relative to the range of accrual rates associated with your prior distribution.

```{r gamma-poisson-after-trial, echo=FALSE, fig.width=5, fig.height=2.5}
f <- "gamma-poisson-after-trial"
data.frame(
  i="after",
  lambda=341/ 1336,
  stringsAsFactors=FALSE) %>%
  bind_rows(sim_gp1)      -> sim_gp3

# head(sim_gp3)

# Boxplot of total sample size
sim_gp3                                  %>%
  ggplot(aes(i, lambda*30))               +
  ylab("patients per month")              + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()
```

Okay, so you were way off. No one is going to hang you. 

## Hedging priors

```{r hedging-extension-before-trial, echo=FALSE, fig.width=5, fig.height=2}
f <- "hedging-extension-before-trial.stan"
dat_before <- list(N=350, T=3*365, S=0.5)
fit_h11 <- stan(file=f,
  data=dat_before, iter= 1000, chains = 4)

# tidy(fit_h11, conf.int=TRUE)

fit_h11              %>%
  as.data.frame      %>%
  mutate(i="before") -> sim_h11

# Boxplot of total sample size
sim_h11                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")               + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()
```

```{r hedging-extension-during-trial, echo=FALSE, fig.width=5, fig.height=2.5}
f <- "hedging-extension-during-trial.stan"
dat_during <- list(N=350, T=3*365, S=0.5, n=41, t=239)
fit_h12 <- stan(file=f,
  data=dat_during, iter= 1000, chains = 4)

# tidy(fit_h12, conf.int=TRUE)

fit_h12              %>%
  as.data.frame      %>%
  mutate(i="during") %>%
  bind_rows(sim_h11) -> sim_h12

# Boxplot of total sample size
sim_h12                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")     + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()
```

```{r hedging-extension-after-trial, echo=FALSE, fig.width=5, fig.height=2.5}
data.frame(
  i="after",
  lambda=341/ 1336,
  stringsAsFactors=FALSE) %>%
  bind_rows(sim_h11)      -> sim_h13

# head(sim_h13)

# Boxplot of total sample size
sim_h13                                  %>%
  ggplot(aes(i, lambda*30))               +
  ylab("patients per month")              + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()
```

## Modeling accrual delays

```{r delay-three, fig.height=2}
f <- "delay-three-parameter-extension-before-trial.stan"
dat_before <- list(N=350, T=3*365, S=0.5)
fit_d31 <- stan(file=f,
  data=dat_before, iter= 1000, chains = 4)

# tidy(fit_d31, conf.int=TRUE)

fit_d31              %>%
  as.data.frame      %>%
  mutate(i="before") -> sim_d31
```{r boxplot3. fog/height}
# Boxplot of total sample size
sim_d31                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")     + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()

# Scatterplot of accrual rate versus total sample size
sim_d31                                  %>%
  ggplot(aes(30*lambda, Nstar))           +
  ylab("Estimated total sample size")     + 
  xlab("Accrual rate")                    +
  geom_point()

sim_d31                                  %>%
  ggplot(aes(alpha, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Time before first accrual")       +
  geom_point()

sim_d31                                  %>%
  ggplot(aes(omega, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Time until full accrual")         +
  geom_point()

sim_d31                                  %>%
  ggplot(aes(delta, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Startup accrual penalty")         +
  geom_point()
```

## Modeling multi-center trials.

```{r hierarchical-one, fig.height=2.5}
f <- "hierarchical-one-parameter-extension-before-trial.stan"
dat_before <- list(N=350, T=3*365, S=0.5, M=10)
fit_h11 <- stan(file=f,
  data=dat_before, iter= 1000, chains = 4)

# tidy(fit_h11, conf.int=TRUE)

fit_h11              %>%
  as.data.frame      %>%
  mutate(i="before") -> sim_h11

# Boxplot of total sample size
sim_h11                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")     + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()

# Scatterplot of accrual rate versus total sample size
sim_h11                                  %>%
  ggplot(aes(30*mu, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Accrual rate")                    +
  geom_point()

sim_h11                                  %>%
  ggplot(aes(scale, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Hierarchical spread")             +
  geom_point()
```

```{r hierarchical-two-parameter-extension-before-trial, echo=FALSE}
f <- "hierarchical-two-parameter-extension-before-trial.stan"
dat_before <- list(N=350, T=3*365, S=0.5, M=10,
                   B=c(20, 5, 5, 10, 10, 5, 10, 10, 5, 20))
fit_h21 <- stan(file=f,
  data=dat_before, iter= 1000, chains = 4)

tidy(fit_h21, conf.int=TRUE)

fit_h21              %>%
  as.data.frame      %>%
  mutate(i="before") -> sim_h21

# Boxplot of total sample size
sim_h21                                  %>%
  ggplot(aes(i, Nstar))                   +
  expand_limits(y=0)                      +
  ylab("Estimated total sample size")     + 
  xlab(" ")                               +
  geom_boxplot()                          +
  coord_flip()

# Scatterplot of accrual rate versus total sample size
sim_h21                                  %>%
  ggplot(aes(30*mu, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Accrual rate")                    +
  geom_point()

sim_h21                                  %>%
  ggplot(aes(scale, Nstar))               +
  ylab("Estimated total sample size")     + 
  xlab("Hierarchical spread")             +
  geom_point()
```

Final comments???